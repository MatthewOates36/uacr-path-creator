//js code to run the path page of the webdashboard,
//which has a table and graph to create and view purepursuit paths

//The path graph canvas from the html page
let pathCanvas = document.getElementById("pathGraph");

//The trajectory graph canvas from the html page
let trajectoryCanvas = document.getElementById("trajectoryGraph");

//Create the path graph using chart.js
let pathGraph = new Chart(pathCanvas, {
    //Configures graph type to scatter plot
    type: 'scatter',
    data: {
        //Sets the datasets to an empty array to be filled later
        datasets: []
    },
    options: {
        //Configures graph to give hover text over points
        responsive: true,
        //Configures graph to allow for access ratio changes
        maintainAspectRatio: false,
        legend: {
            labels: {
                //Set the graph legend text to the --white color specified in style.css
                fontColor: getComputedStyle(document.documentElement).getPropertyValue('--white'),
                //Set the font size of the labels in the legend to 18px
                fontSize: 18
            }
        },
        scales: {
            yAxes: [{
                ticks: {
                    //Sets the graph yAxes tick color to the --graph color specified in style.css
                    fontColor: getComputedStyle(document.documentElement).getPropertyValue('--graph')
                }
            }],
            xAxes: [{
                ticks: {
                    //Sets the graph xAxes tick color to the --graph color specified in style.css
                    fontColor: getComputedStyle(document.documentElement).getPropertyValue('--graph')
                }
            }]
        },
        animation: {
            //Removes graph dataset change animations
            duration: 0
        },
        plugins: {
            zoom: {
                pan: {
                    enabled: true,
                    mode: function({ chart }) {
                        let mode = "";
                        if($("#scroll")[0].checked) {
                            if(!$("#autorangeX")[0].checked) {
                                mode += "x";
                            }
                            if(!$("#autorangeY")[0].checked) {
                                mode += "y";
                            }
                        }
                        return mode;
                    },
                },
                zoom: {
                    enabled: true,
                    mode: function({ chart }) {
                        let mode = "";
                        if($("#zoom")[0].checked) {
                            if(!$("#autorangeX")[0].checked) {
                                mode += "x";
                            }
                            if(!$("#autorangeY")[0].checked) {
                                mode += "y";
                            }
                        }
                        return mode;
                    },
                    speed: 0.1
                }
            }
        }
    }
});

//Create the path graph using chart.js
let trajectoryGraph = new Chart(trajectoryCanvas, {
    //Configures graph type to scatter plot
    type: 'scatter',
    data: {
        //Sets the datasets to an empty array to be filled later
        datasets: []
    },
    options: {
        //Configures graph to give hover text over points
        responsive: true,
        //Configures graph to allow for access ratio changes
        maintainAspectRatio: false,
        legend: {
            labels: {
                //Set the graph legend text to the --white color specified in style.css
                fontColor: getComputedStyle(document.documentElement).getPropertyValue('--white'),
                //Set the font size of the labels in the legend to 18px
                fontSize: 18
            }
        },
        scales: {
            yAxes: [{
                ticks: {
                    //Sets the graph yAxes tick color to the --graph color specified in style.css
                    fontColor: getComputedStyle(document.documentElement).getPropertyValue('--graph')
                }
            }],
            xAxes: [{
                ticks: {
                    //Sets the graph xAxes tick color to the --graph color specified in style.css
                    fontColor: getComputedStyle(document.documentElement).getPropertyValue('--graph')
                }
            }]
        },
        animation: {
            //Removes graph dataset change animations
            duration: 0
        }
    }
});

//Create an empty array for the points added by the user
let waypoints = [];

//Create an empty array for the points generated by the program based on the waypoints entered by the user
let points = [];

//Create an empty array for the path points generated by the program based on the waypoints entered by the user
let path = [];

//The spacing between each point
let fSpacing = 2.0;

//The amount of overall path smoothing
let fSmoothing = 0.7;

//The max acceleration (total output/point)
let fMaxAcceleration = 0.01;

//The max deceleration (total output/point)
let fMaxDeceleration = 0.005;

//Minimum follow speed
let fMinSpeed = 0.2;

//Maximum follow speed
let fMaxSpeed = 1.0;

//Speed reduction through turns (larger number = faster turns)
let fTurnSpeed = 1.0;



//Create context menu
let BB = pathCanvas.getBoundingClientRect();
let offsetX = BB.left;
let offsetY = BB.top;

pathCanvas.oncontextmenu = function (e) {
    e.preventDefault();
    e.stopPropagation();

    let graphContextMenu = $("#graphContextMenu");

    let x = e.clientX + offsetX;
    let y = e.clientY + offsetY;

    graphContextMenu.css({left: x, top: y});
    graphContextMenu.show();

    return false;
};

pathCanvas.onclick = function (e) {
    e.preventDefault();
    e.stopPropagation();

    $("#graphContextMenu").hide();
};

$("#graphContextMenu").onclick = function (e) {
    e.preventDefault();
    e.stopPropagation();
};

$("#graphContextMenu").dblclick(function (e) {
    e.preventDefault();
    e.stopPropagation();
});

$("#autorangeX").change(function (e) {
    if($("#autorangeX")[0].checked) {
        pathGraph.resetZoom();
    }
});

$("#autorangeY").change(function (e) {
    if($("#autorangeY")[0].checked) {
        pathGraph.resetZoom();
    }
});



//Opens the menu when a double click occurs anywhere on the page
function openMenu() {

    //Set the menu to be visible
    setVisibility(document.getElementById("menuPopup"), true);

    $("#graphContextMenu").hide();
}

//Closes the menu, called when the close button is pressed
function closeMenu() {

    //Hide the menu
    setVisibility(document.getElementById("menuPopup"), false);
}

//Copy to the system clipboard the current waypoints as a yaml array when the copy button is pressed
function copyToClipboard() {

    //Create a textarea in which the text will be put then copied to the system clipboard
    let textArea = document.createElement('textarea');

    //Create an empty array where the wey points to be copied will be put
    let path = "";

    //Loop through all the waypoints
    for (let point of waypoints) {

        //Add each point to the path string
        path += "[" + point.x + ", " + point.y + "], ";
    }


    if (path.length > 0) {
        //If the path has points remove the extra comma and space from the last point
        path = path.trim().substring(0, path.length - 2);
    }

    //Add the extra brackets to make the waypoints into a yaml array
    path = "[" + path + "]";

    //Make the textarea read only to prevent the user from editing the array on accident
    textArea.setAttribute('readonly', '');

    //Set the value of the textarea to the yaml waypoint array
    textArea.value = path;

    //Set the textarea display to none so when it is added to the html page it will not be dipslayed
    textArea.display = 'none';

    //Add the textarea to the html page
    document.body.appendChild(textArea);

    //Select all the text in the textarea automatically
    textArea.select();

    //Execute the copy command copying the entire array onto the clipboard
    document.execCommand('copy');

    //Remove the textarea from the document now that the copy is complete
    document.body.removeChild(textArea);
}

//Opens the paste menu, called when the paste button is pressed
function openPaste() {

    //Set the paste menu to be visible
    setVisibility(document.getElementById("pastePopup"), true);

    //Select the paste input automatically
    document.getElementById('pathInput').focus();
    document.getElementById('pathInput').select();
}

//Closes the paste menu, called when the closePaste button is pressed
//"shouldPaste" is whether the data in the input will be put into the table and graph
function closePaste(shouldPaste) {
    if (shouldPaste) {
        //If the data should be put into the table and graph

        //Get the data from the input field
        let text = document.getElementById("pathInput").value;

        //Remove any special characters
        text = text.replace(/(\r\n|\n|\r|\s)/gm, "");

        //Remove the starting and ending brackets
        text = text.substring(1, text.length - 1);

        //Split up the input on the open brackets
        text = text.split("[");

        //Remove the empty first section
        text.splice(0, 1);

        //Clear the current data so the new data can be entered
        clearPath();

        //Get all the rows from the input table body
        let rows = document.getElementById("pointTableBody").rows;

        //Loop through each point
        for (let p in text) {

            //Remove the extra character to get "x,y" for the point
            let point = text[p].replace("],", "").replace("]", "");

            //Get the row that the data will be put into
            let row = rows[p];

            //Put the x-value in the first cell
            row.cells[0].innerText = point.split(",")[0];

            //Put the y-value in the second cell
            row.cells[1].innerText = point.split(",")[1];
        }

        //Update the page to show changes
        update();

        //Close the main menu
        closeMenu();
    }

    //Hide the paste menu
    setVisibility(document.getElementById("pastePopup"), false);
}

//Opens the settings menu, called when the path settings button is pressed
function openSettings() {
    //Update the inputs to the current values
    document.getElementById("spacingInput").value = fSpacing;
    document.getElementById("smoothingInput").value = fSmoothing;
    document.getElementById("maxSpeedInput").value = fMaxSpeed;
    document.getElementById("minSpeedInput").value = fMinSpeed;
    document.getElementById("maxAccelerationInput").value = fMaxAcceleration;
    document.getElementById("maxDecelerationInput").value = fMaxDeceleration;
    document.getElementById("turnSpeedInput").value = fTurnSpeed;

    //Set the settings menu to be visible
    setVisibility(document.getElementById("settingsPopup"), true);
}

//Copy to the system clipboard the current path settings as a yaml map when the settingsCopy button is pressed
function copySettings() {

    //Create a textarea in which the text will be put then copied to the system clipboard
    let textArea = document.createElement('textarea');

    //Make string to hold all the settings
    let settings = "";

    settings += "spacing: " + parseFloat(document.getElementById("spacingInput").value) + "\n";
    settings += "smoothing: " + parseFloat(document.getElementById("smoothingInput").value) + "\n";
    settings += "max_speed: " + parseFloat(document.getElementById("maxSpeedInput").value) + "\n";
    settings += "min_speed: " + parseFloat(document.getElementById("minSpeedInput").value) + "\n";
    settings += "max_acceleration: " + parseFloat(document.getElementById("maxAccelerationInput").value) + "\n";
    settings += "max_deceleration: " + parseFloat(document.getElementById("maxDecelerationInput").value) + "\n";
    settings += "turn_speed: " + parseFloat(document.getElementById("turnSpeedInput").value) + "\n";

    //Make the textarea read only to prevent the user from editing the array on accident
    textArea.setAttribute('readonly', '');

    //Set the value of the textarea to the yaml waypoint array
    textArea.value = settings;

    //Set the textarea display to none so when it is added to the html page it will not be dipslayed
    textArea.display = 'none';

    //Add the textarea to the html page
    document.body.appendChild(textArea);

    //Select all the text in the textarea automatically
    textArea.select();

    //Execute the copy command copying the entire array onto the clipboard
    document.execCommand('copy');

    //Remove the textarea from the document now that the copy is complete
    document.body.removeChild(textArea);
}

//Opens the settings paste menu, called when the settingsPaste button is pressed
function pasteSettings() {

    //Set the settings paste menu to be visible
    setVisibility(document.getElementById("settingsPastePopup"), true);

    //Select the settings paste input automatically
    document.getElementById('settingsInput').focus();
    document.getElementById('settingsInput').select();
}

//Closes the paste menu, called when the closePaste button is pressed
//"shouldPaste" is whether the data in the input will be put into the table and graph
function closeSettingsPaste(shouldPaste) {
    if (shouldPaste) {
        //If the data should be put into the table and graph

        //Get the data from the input field
        let text = document.getElementById("settingsInput").value;

        //Get each yaml line
        let parts = text.split("\n");

        for (let part of parts) {
            //Remove leading and trailing white spaces from the line
            part = part.trim();

            //Remove any special characters
            part = part.replace(/(\r\n|\n|\r|\s)/gm, "");

            //Get sections of the yaml line
            let sections = part.split(":");

            //Get the yaml key and value
            let key = sections[0].trim();
            let value = parseFloat(sections[1]);

            //Set the value based on the key
            switch (key) {
                case "spacing":
                    fSpacing = value;
                    break;
                case "smoothing":
                    fSmoothing = value;
                    break;
                case "max_speed":
                    fMaxSpeed = value;
                    break;
                case "min_speed":
                    fMinSpeed = value;
                    break;
                case "max_acceleration":
                    fMaxAcceleration = value;
                    break;
                case "max_deceleration":
                    fMaxDeceleration = value;
                    break;
                case "turn_speed":
                    fTurnSpeed = value;
                    break;
            }
        }

        //Update the page to show changes
        update();

        //Close the main menu
        closeMenu();
    }

    //Hide the settings paste menu
    setVisibility(document.getElementById("settingsPastePopup"), false);
}

//Closes the settings menu, called when the closeSettings button is pressed
//"shouldSave" is whether the data will be saved
function closeSettings(shouldSave) {
    if (shouldSave) {
        //If the inputs should be saved set them to the variables
        fSpacing = parseFloat(document.getElementById("spacingInput").value);
        fSmoothing = parseFloat(document.getElementById("smoothingInput").value);
        fMaxSpeed = parseFloat(document.getElementById("maxSpeedInput").value);
        fMinSpeed = parseFloat(document.getElementById("minSpeedInput").value);
        fMaxAcceleration = parseFloat(document.getElementById("maxAccelerationInput").value);
        fMaxDeceleration = parseFloat(document.getElementById("maxDecelerationInput").value);
        fTurnSpeed = parseFloat(document.getElementById("turnSpeedInput").value);

        //Update the display
        update();

        //Close the main menu
        closeMenu();
    }

    //Set the settings menu to be hidden
    setVisibility(document.getElementById("settingsPopup"), false);
}

//Adds data to a dataset, creating a new dataset if needed
//"label" is the label of the dataset
//"data" is the data to be added to the dataset
//"color" the css variable name of the color
function addData(graph, label, data, color) {

    if (color === undefined) {
        //If no color was set, use the default graph color
        color = "--graph";
    }

    //Loop through all of the datasets on the graph to try and find a dataset with a matching label
    for (let dataset of pathGraph.data.datasets) {

        if (dataset.label === label) {
            //If the labels match add the new data to the dataset

            //Loop through each point and add it to the dataset
            for (let point of data) {
                dataset.data.push(point);
            }

            //Update the graph to show changes
            pathGraph.update();
            return;
        }
    }

    //If no dataset is found matching the label create a new dataset

    let dataset = {

        //Set the dataset label the the label passed in
        label: label,

        //Sets the label to the --graph color specified in style.css color specified in style.css
        labelColor: getComputedStyle(document.documentElement).getPropertyValue(color),

        //Sets the point border and background colors --graph color specified in style.css color specified in style.css
        borderColor: getComputedStyle(document.documentElement).getPropertyValue(color),
        backgroundColor: getComputedStyle(document.documentElement).getPropertyValue(color),

        //Sets the radius of the points to 5px
        pointRadius: 5,

        //Sets the data in the dataset to the data passed in
        data: data
    };

    //Add the dataset to the graph
    graph.data.datasets.push(dataset);

    //Update the graph to show changes
    graph.update();
}

//Removes all datasets from the graph
function removeData(graph) {
    //Clears all datasets
    graph.data.datasets = [];

    //Updates the chart to display to changes
    graph.update();
}

//Removes all data from the path
function clearPath() {
    //Removes all the data
    localStorage['way_points'] = "";

    //Loops through each row in the input table body
    for (let row of document.getElementById("pointTableBody").rows) {

        //Clear the first cell in the row
        row.cells[0].innerText = "";

        //Clear the second cell in the row
        row.cells[1].innerText = "";
    }

    //Remove all data from the graph
    removeData(pathGraph);
    removeData(trajectoryGraph);
}

//Mirrors the java build method in the purepursuit Path class
function build() {
    waypoints = [];

    for (let row of document.getElementById("pointTableBody").rows) {
        if ((parseFloat(row.cells[0].innerText) || row.cells[0].innerText === '0') && (parseFloat(row.cells[1].innerText) || row.cells[1].innerText === '0')) waypoints.push(new Point(parseFloat(row.cells[0].innerText), parseFloat(row.cells[1].innerText)));
    }

    localStorage['way_points'] = waypoints.join("*");

    fill();

    smooth();

    createPath();

    return true;
}

//Mirrors the java fill method in the purepursuit Path class
function fill() {

    let newPoints = [];

    for (let s = 1; s < waypoints.length; s++) {
        let vector = new Vector(waypoints[s - 1], waypoints[s]);

        let numPointsFit = Math.round(Math.ceil(vector.magnitude / fSpacing));

        vector = vector.normalize().scale(fSpacing);

        for (let i = 0; i < numPointsFit; i++) {
            newPoints.push(waypoints[s - 1].add(vector.scale(i)));
        }
    }

    newPoints.push(waypoints[waypoints.length - 1]);

    points = newPoints;
}

//Mirrors the java smooth method in the purepursuit Path class
function smooth() {
    let change = 0.5;
    let changedPoints = 1;
    while (change / changedPoints >= 0.01) {
        change = 0;
        changedPoints = 0;

        let newPoints = [...points];

        for (let i = 1; i < points.length - 1; i++) {
            let point = points[i];

            let middle = new Vector(points[i + 1].subtract(points[i - 1]));

            middle = new Vector(points[i - 1].add(middle.normalize().scale(middle.magnitude / 2)));

            let delta = new Vector(middle.subtract(point));

            let newPoint = point.add(delta.normalize().scale(delta.magnitude * fSmoothing));

            if (!isNaN(newPoint.x) && !isNaN(newPoint.y)) {
                newPoints[i] = newPoint;
                change += point.distance(newPoint);
                changedPoints++;
            }
        }

        points = newPoints;
    }
}

//Mirrors the java createPath method in the purepursuit Path class
function createPath() {

    path = [];

    for (let p = 0; p < points.length; p++) {
        if (points[p] !== undefined) {
            path.push(new PathPoint(points[p].x, points[p].y, getPointDistance(p), getPointCurvature(p), getPointVelocity(p)));
        }
    }

    for (let p = points.length - 2; p >= 0; p--) {
        path[p].velocity = getPointNewVelocity(p);
    }
}

//Mirrors the java getPointDistance method in the purepursuit Path class
function getPointDistance(p) {
    if (p === 0) {
        return 0.0;
    }

    return points[p].distance(points[p - 1]) + path[p - 1].startDistance;
}

//Mirrors the java getPointCurvature method in the purepursuit Path class
function getPointCurvature(p) {
    if (p <= 0 || p >= points.length - 1) return 0.0;
    return getCurvature(points[p], points[p - 1], points[p + 1]);
}

//Mirrors the java getCurvature method in the purepursuit Path class
function getCurvature(p1, p2, p3) {
    let x1 = p1.x, y1 = p1.y;
    let x2 = p2.x, y2 = p2.y;
    let x3 = p3.x, y3 = p3.y;
    if (x1 === x2) x1 += 0.0001;
    let k1 = 0.5 * (Math.pow(x1, 2) + Math.pow(y1, 2) - Math.pow(x2, 2) - Math.pow(y2, 2)) / (x1 - x2);
    let k2 = (y1 - y2) / (x1 - x2);
    let b = 0.5 * (Math.pow(x2, 2) - 2 * x2 * k1 + Math.pow(y2, 2) - Math.pow(x3, 2) + 2 * x3 * k1 - Math.pow(y3, 2)) / (x3 * k2 - y3 + y2 - x2 * k2);
    let a = k1 - k2 * b;
    let r = Math.sqrt(Math.pow(x1 - a, 2) + Math.pow(y1 - b, 2));
    let c = 1 / r;
    if (isNaN(c)) {
        return 0.0;
    }
    return c;
}

//Mirrors the java getCurvature method in the purepursuit Path class
function getPointVelocity(p) {
    if (p >= points.length - 2) return fMinSpeed;

    let d = points[p].distance(points[p + 1]);

    if (p <= 0) return Math.max(Math.min(2 * fMaxAcceleration * d, fTurnSpeed / getPointCurvature(p)), fMinSpeed);

    return Math.max(Math.min(path[p - 1].velocity + 2 * fMaxAcceleration * d, Math.min(fTurnSpeed / getPointCurvature(p), fMaxSpeed)), fMinSpeed);
}

//Mirrors the java getPointNewVelocity method in the purepursuit Path class
function getPointNewVelocity(p) {
    if (p >= points.length - 2) return fMinSpeed;

    let d = points[p].distance(points[p + 1]);

    return Math.min(path[p].velocity, Math.min(path[p + 1].velocity + 2 * fMaxDeceleration * d, fMaxSpeed));
}

//Update the path, called whenever the data changes
function update() {

    //Build the path with the new data
    build();

    //Remove the old data from the graph
    removeData(pathGraph);
    removeData(trajectoryGraph);

    //Make an array for the new datasets
    let data = [];

    //Loop through each waypoint
    for (let point of waypoints) {
        if (point !== undefined) {
            //If the point is not undefined at it to the dataset
            data.push({x: point.x, y: point.y});
        }
    }

    //Put the new dataset onto the graph
    addData(pathGraph, "Waypoints", data, "--yellow");

    //Clear the data array for the next dataset
    data = [];

    //Loop through each point
    for (let point of points) {
        if (point !== undefined) {
            //If the point is not undefined at it to the dataset
            data.push({x: point.x, y: point.y});
        }
    }

    //Put the new dataset onto the graph
    addData(pathGraph, "Path", data);

    let velocityData = [];
    let curvatureData = [];

    for (let point of path) {
        if (point !== undefined) {
            //If the point is not undefined at it to the dataset
            velocityData.push({x: point.startDistance, y: point.velocity});
            curvatureData.push({x: point.startDistance, y: point.curvature});
        }
    }

    //Put the new datasets onto the trajectory graph
    addData(trajectoryGraph, "Velocity", velocityData, "--yellow");
    addData(trajectoryGraph, "Curvature", curvatureData, "--blue");
}

//Used to show and hide an element
//"element" is the element
//"visible" is whether the element should be displayed
function setVisibility(element, visible) {
    //Show or hide the element using the visibility property based on the visible variable
    if (visible) {
        element.style.visibility = "visible";
    } else {
        element.style.visibility = "hidden";
    }

    //Get children of the element
    let children = element.children;

    //Loop through and show or hide the element's children using the visibility property based on the visible variable
    for (let c = 0; c < children.length; c++) {
        if (visible) {
            children[c].style.visibility = "visible";
        } else {
            children[c].style.visibility = "hidden";
        }
    }
}

//KeyListener which is added to each cell to allow the user to move the cursor with the up and down arrow keys
function keyListener(event) {

    if (event.key === "ArrowDown") {
        //If the key was the down arrow

        //Stop what the key would normally do
        event.preventDefault();

        //Get the rows of the input table
        let rows = document.getElementById("pointTable").rows;

        //Loop through the table rows
        for (let r = 0; r < rows.length; r++) {

            //Get the table row element
            let row = rows[r];

            if (row.cells[0] === event.target) {
                //If the target of the key event was the first cell in the row,
                //move the cursor to the second cell in the same row
                row.cells[1].focus();
            }

            if (row.cells[1] === event.target) {
                //If the target of the key event was the second cell in the row,
                //move the cursor to the first cell in the next row
                rows[r + 1].cells[0].focus();
            }
        }
    } else if (event.key === "ArrowUp") {
        //If the key was the up arrow

        //Stop what the key would normally do
        event.preventDefault();

        //Get the rows of the input table
        let rows = document.getElementById("pointTable").rows;

        //Loop through the table rows
        for (let r = 0; r < rows.length; r++) {

            //Get the table row element
            let row = rows[r];

            if (row.cells[0] === event.target) {
                //If the target of the key event was the first cell in the row,
                //move the cursor to the second cell in the previous row
                rows[r - 1].cells[1].focus();
            }

            if (row.cells[1] === event.target) {
                //If the target of the key event was the second cell in the row,
                //move the cursor to the first cell in the same row
                row.cells[0].focus();
            }
        }
    }

    //Update the table and graph every time any key is pressed
    setTimeout(update, 100);
}

//Create all the rows and cells in the waypoint input table
for (let i = 0; i < 100; i++) {

    //Create a new row
    let r = document.getElementById("pointTableBody").insertRow();

    //Create the first cell in the row
    let cell = r.insertCell(0);

    //Allow the user to edit the cell
    cell.contentEditable = 'true';

    //Add the keyListener for move the cursor to the cell
    cell.addEventListener("keydown", keyListener);

    //Create the second cell in the row
    cell = r.insertCell(1);

    //Allow the user to edit the cell
    cell.contentEditable = 'true';

    //Add the keyListener for move the cursor to the cell
    cell.addEventListener("keydown", keyListener);
}

if (localStorage['way_points'] !== undefined && localStorage['way_points'] !== "") {
    //If on page load the waypoints in local storage exist, then put them into the input table and graph

    //Get the waypoints from localStorage
    let points = localStorage['way_points'].split("*");

    //Loop through the waypoints
    for (let p in points) {

        //Get the waypoint from the array
        let point = points[p];

        //Get correct row from the data input table body
        let row = document.getElementById("pointTableBody").rows[p];

        //Put the x-value in the first cell
        row.cells[0].innerText = point.split(",")[0];

        //Put the y-value in the second cell
        row.cells[1].innerText = point.split(",")[1];
    }

    //Update the page to show changes
    update();
}